#
# wradlib documentation build configuration file, created by
# sphinx-quickstart on Wed Oct 26 13:48:08 2011.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import datetime as dt
import glob
import os
import re
import sys
import subprocess
import warnings

from pybtex.plugin import register_plugin  # noqa
from pybtex.style.formatting.unsrt import Style  # noqa
from pybtex.style.labels.alpha import LabelStyle, _strip_nonalnum  # noqa

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
# sys.path.insert(0, os.path.abspath('.'))
# sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

# -- General configuration ----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    # "nbsphinx",
    "sphinx.ext.autodoc",
    "sphinx.ext.autosectionlabel",
    "sphinx.ext.autosummary",
    "sphinx.ext.coverage",
    "sphinx.ext.extlinks",
    "sphinx.ext.intersphinx",
    "sphinx.ext.napoleon",
    "sphinx.ext.mathjax",
    "sphinx.ext.todo",
    "sphinx.ext.viewcode",
    "sphinxcontrib.bibtex",
    # "myst_parser",
    "myst_nb",
    "sphinx_copybutton",
    "IPython.sphinxext.ipython_console_highlighting",
]

autodoc_default_options = {
    "members": True,
    "member-order": "bysource",
    "special-members": False,
    "undoc-members": True,
    "exclude-members": "__weakref__",
    "class-doc-from": "class",
    "show-inheritance": True,
}

autosectionlabel_prefix_document = True
autosectionlabel_maxdepth = 3

myst_enable_extensions = [
    "substitution",
    "dollarmath",
    "amsmath",
    "colon_fence",
    "deflist",
    "html_image",
    "linkify",
    "tasklist",
]

myst_heading_anchors = 5


extlinks = {
    "issue": ("https://github.com/wradlib/wradlib/issues/%s", "GH%s"),
    "pull": ("https://github.com/wradlib/wradlib/pull/%s", "PR%s"),
    "at": ("https://github.com/%s", "@%s"),
}

# mathjax_path = ("https://cdn.mathjax.org/mathjax/latest/MathJax.js?"
#                "config=TeX-AMS-MML_HTMLorMML")

# The suffix of source filenames.
# source_suffix = [".rst", ".md"]

source_suffix = {
    ".rst": "restructuredtext",
    ".ipynb": "myst-nb",
    ".myst": "myst-nb",
    ".md": "myst-nb",
}


# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The main toctree document.
master_doc = "index"

# General information about the project.
project = "wradlib"
copyright = "2011-2025, wradlib developers"
author = "Wradlib Community"
url = "https://github.com/wradlib"

# get version from metadata
from importlib.metadata import version as metadata_version

# check readthedocs
on_rtd = os.environ.get("READTHEDOCS") == "True"


version = metadata_version("wradlib")
release = version

print("RELEASE, VERSION", release, version)

# get wradlib modules and create automodule rst-files
import types

# get wradlib version
import wradlib  # noqa

modules = []
for k, v in wradlib.__dict__.items():
    if isinstance(v, types.ModuleType):
        if k not in ["_warnings", "version"]:
            modules.append(k)
            with open(f"{k}.rst", mode="w") as f:
                f.write(f".. automodule:: wradlib.{k}\n")

# create API/Library reference md-file
reference = """# Library Reference

This page contains an auto-generated summary of {{wradlib}}'s API. Every submodule is documented separately.

```{toctree}
:maxdepth: 2
"""

with open("reference.md", mode="w") as f:
    f.write(f"{reference}\n")
    for mod in sorted(modules):
        f.write(f"{mod}\n")
    f.write("```")

# get all rst files, do it manually
rst_files = glob.glob("*.rst")
autosummary_generate = rst_files
autosummary_generate_overwrite = True
autosummary_imported_members = False
autodoc_default_options = {
    "ignore-module-all": True,
}

myst_substitutions = {
    "today": dt.datetime.utcnow().strftime("%Y-%m-%d"),
    "release": release,
    "wradlib": "$\\omega radlib$",
    "xradar": "[xradar](https://xradar.rtfd.io)",
    "xarray": "[xarray](https://docs.xarray.dev)",
    "dask": "[Dask](https://docs.dask.org)",
}

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = "%Y-%m-%d"

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# exclude_patterns = []
exclude_patterns = [
    "_build",
    "Thumbs.db",
    ".DS_Store",
    "links.rst",
    "**.ipynb_checkpoints",
    # "examples/notebooks/**/*.md",
    # "examples/notebooks/*.md",
    #    "generated/*",
]

# -- myst_nb specifics --
nb_execution_mode = "auto"
nb_execution_kernel_name = "python3"
nb_execution_in_temp = True
nb_execution_timeout = 300

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"

# linkcheck options
linkcheck_ignore = ["https://data.apps.fao.org/map/catalog/srv/eng/catalog.search#"]

# -- Options for HTML output --------------------------------------------------


# Tell the theme where the code lives
# adapted from https://github.com/vispy/vispy


def get_docpath_filename(filename, modpath):
    docpath = None
    rel_modpath = os.path.join("..", modpath)
    if os.path.isdir(rel_modpath):
        docpath = modpath + "/"
        filename = "__init__.py"
    elif os.path.isfile(rel_modpath + ".py"):
        docpath = os.path.dirname(modpath)
        filename = os.path.basename(modpath) + ".py"
    else:
        modpath, _ = os.path.split(modpath)
        docpath, filename = get_docpath_filename(filename, modpath)
    return docpath, filename


html_context = {
    "github_user": "wradlib",
    "github_repo": "wradlib",
    "github_version": "main",
    "doc_path": "docs",
    "edit_page_url_template": (
        "https://github.com/{{ github_user }}/{{ github_repo }}/edit/"
        "{{ github_version }}/{{ doc_path }}{{ file_name }}"
    ),
}

# Theme options are theme-specific and customize the look and feel of a
# theme further. For a list of options available for each theme, see the
# documentation.
#
html_theme_options = {
    "repository_url": "https://github.com/wradlib/wradlib",
    "github_url": "https://github.com/wradlib/wradlib",
    "external_links": [
        {
            "url": "https://github.com/wradlib/wradlib-notebooks/blob/main/notebooks/overview.ipynb",
            "name": "Gallery",
        },
    ],
    "icon_links": [
        {
            "name": "PyPI",
            "url": "https://pypi.org/project/wradlib",
            "icon": "fas fa-box",
        },
        {
            "name": "Openradar Discourse",
            "url": "https://openradar.discourse.group",
            "icon": "fab fa-discourse",
        },
        {
            "type": "local",
            "name": "OpenRadarScience",
            "url": "https://openradarscience.org",
            "icon": "https://raw.githubusercontent.com/openradar/openradar.github.io/main/images/openradar_micro.svg",
        },
    ],
    "navbar_align": "right",
    "navbar_end": ["icon-links.html"],
    "use_edit_page_button": True,
    "use_issues_button": True,
    "use_repository_button": True,
    "repository_branch": "main",
    "path_to_docs": "docs",
}

html_theme = "sphinx_book_theme"

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = project

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = "images/wradlib_logo_small.png"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = "images/favicon.ico"

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

intersphinx_mapping = {
    "python": ("https://docs.python.org/3/", None),
    "numpy": ("https://numpy.org/doc/stable/", None),
    "scipy": ("https://docs.scipy.org/doc/scipy/", None),
    "matplotlib": ("https://matplotlib.org/stable/", None),
    "sphinx": ("https://www.sphinx-doc.org/en/master/", None),
    "xarray": ("https://docs.xarray.dev/en/stable/", None),
    "xradar": ("https://docs.openradarscience.org/projects/xradar/en/stable/", None),
    "datatree": ("https://xarray-datatree.readthedocs.io/en/stable/", None),
    "cartopy": ("https://cartopy.readthedocs.io/stable/", None),
    "gdal": ("https://gdal.org/en/stable/", None),
    "pyproj": ("https://pyproj4.github.io/pyproj/stable/", None),
    "notebooks": ("https://docs.wradlib.org/projects/notebooks/en/latest/", None),
    "radolan": ("https://docs.wradlib.org/projects/radolan/en/latest/", None),
}

# -- Napoleon settings for docstring processing -------------------------------
napoleon_google_docstring = False
napoleon_numpy_docstring = True
napoleon_include_special_with_doc = False
napoleon_use_param = False
napoleon_use_rtype = False
napoleon_preprocess_types = True
napoleon_type_aliases = {
    "scalar": ":term:`scalar`",
    "sequence": ":term:`sequence`",
    "callable": ":py:func:`callable`",
    "file-like": ":term:`file-like <file-like object>`",
    "array-like": ":term:`array-like <array_like>`",
    "Path": "~~pathlib.Path",
}

bibtex_bibfiles = ["refs.bib", "refs_links.bib"]


class WradlibLabelStyle(LabelStyle):
    # copy from AlphaStyle
    def format_label(self, entry):
        if entry.type == "book" or entry.type == "inbook":
            label = self.author_editor_key_label(entry)
        elif entry.type == "proceedings":
            label = self.editor_key_organization_label(entry)
        elif entry.type == "manual":
            label = self.author_key_organization_label(entry)
        else:
            label = self.author_key_label(entry)
        # add full year comma separated
        if "year" in entry.fields:
            return "{}, {}".format(label, entry.fields["year"])
        else:
            return label

    def format_lab_names(self, persons):
        numnames = len(persons)
        person = persons[0]
        result = _strip_nonalnum(person.prelast_names + person.last_names)
        if numnames > 1:
            result += " et al."
        return result


class WradlibStyle(Style):
    default_label_style = "wrl"


register_plugin("pybtex.style.labels", "wrl", WradlibLabelStyle)
register_plugin("pybtex.style.formatting", "wrlstyle", WradlibStyle)

rst_epilog = ""


def normalize_autosectionlabels(app, env):
    """
    Normalize autosectionlabel labels:
      - replace spaces with dashes in section titles
      - shorten document prefix to just the name
    """
    std_labels = env.domaindata["std"]["labels"]
    new_labels = {}

    for key, (docname, labelid, sectname) in list(std_labels.items()):
        # take only last part of the path
        short_prefix = docname.split("/")[-1]

        # replace spaces with dashes in section title
        if ":" in key:
            prefix, title = key.split(":", 1)
            title_dash = re.sub(r"\s+", "-", title.strip())
            new_key = f"{short_prefix}:{title_dash}"
        else:
            new_key = re.sub(r"\s+", "-", key.strip())

        # do not overwrite
        if new_key not in std_labels and new_key not in new_labels:
            new_labels[new_key] = (docname, labelid, sectname)

    std_labels.update(new_labels)


def dump_docs(app, env):
    print("\n=== DOCNAMES registered ===")
    for d in sorted(env.found_docs):
        print(d)
    print("=== END DOCNAMES ===\n")


def setup(app):
    app.connect("env-updated", normalize_autosectionlabels)
    app.connect("env-updated", dump_docs)
